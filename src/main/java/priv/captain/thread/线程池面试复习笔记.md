📘 Java 面试复习笔记：ThreadPoolExecutor 线程池

✅ 一、概念简介

**是什么？**

Java 线程池（`ThreadPoolExecutor`）是一种管理和复用线程的机制，它将线程的创建、销毁、调度等工作统一管理起来。当有任务需要执行时，线程池会分配一个空闲线程来执行；任务执行完毕后，线程不会被销毁，而是回到线程池中等待下一个任务。

**为什么用？**

🎯 **核心目的：** 降低资源消耗、提高响应速度、增强线程管理能力。

  * **降低资源消耗：** 频繁地创建和销毁线程开销很大，线程池通过复用已创建的线程，避免了这些不必要的开销。
  * **提高响应速度：** 当任务到达时，可以直接从池中获取可用线程并立即执行，无需等待线程创建，因此响应速度更快。
  * **提高线程可管理性：** 线程是稀缺资源，无限制地创建线程可能导致系统资源耗尽或过度竞争。线程池可以统一配置和管理，如最大线程数、排队策略等，防止资源被耗尽。

**与直接创建线程的区别**

| 特性 | ThreadPoolExecutor | new Thread() |
| :--- | :--- | :--- |
| **资源消耗** | 低。复用线程，减少创建和销毁开销。 | 高。每次创建和销毁都有开销。 |
| **响应速度** | 快。任务直接从池中获取线程执行。 | 慢。需要等待线程创建。 |
| **管理性** | 强。可以统一配置最大线程数、队列等。 | 弱。无法统一控制，可能导致 OOM。 |
| **应用场景** | 大量短期任务、Web 服务器等。 | 少量、一次性、独立运行的任务。 |

-----

🔹 二、底层原理 + 源码分析

线程池的核心是 `ThreadPoolExecutor` 类。它的工作流程和核心参数是面试的重中之重。

**核心构造函数**

```java
public ThreadPoolExecutor(
    int corePoolSize, // 核心线程数
    int maximumPoolSize, // 最大线程数
    long keepAliveTime, // 线程空闲时间
    TimeUnit unit, // keepAliveTime 的单位
    BlockingQueue<Runnable> workQueue, // 任务队列
    ThreadFactory threadFactory, // 线程工厂
    RejectedExecutionHandler handler // 拒绝策略
) { ... }
```

**执行流程（`execute()` 方法解析）**

当调用 `execute(Runnable command)` 提交一个任务时，线程池的执行流程严格遵循以下规则：

1.  **小于核心线程数？**

      * 如果当前运行的线程数 `<` `corePoolSize`，则会立即创建一个新线程来执行任务。
      * **设计意图：** 优先保证核心线程的存活，快速响应新任务。

2.  **核心线程已满，但任务队列未满？**

      * 如果当前运行的线程数 `>=` `corePoolSize`，但任务队列 `workQueue` 未满，则将任务放入任务队列等待执行。
      * **设计意图：** 优先将任务排队，而不是盲目创建新线程，以减少资源消耗。

3.  **核心线程已满，任务队列已满，但小于最大线程数？**

      * 如果 `corePoolSize` 已满，`workQueue` 也已满，但当前运行的线程数 `<` `maximumPoolSize`，则会创建非核心线程来执行任务。
      * **设计意图：** 当任务量激增时，通过创建“救火”线程来应对高峰。

4.  **所有资源都满了？**

      * 如果当前线程数 `>=` `maximumPoolSize`，并且任务队列 `workQueue` 也已满，线程池将根据 **拒绝策略（`RejectedExecutionHandler`）** 来处理该任务。
      * **设计意图：** 确保线程池资源不被耗尽，提供一个“兜底”机制。

**源码解析 - `execute()` 关键逻辑**

```java
// ThreadPoolExecutor.java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();

    int c = ctl.get();
    // 1. 如果当前工作线程数少于核心线程数，直接创建核心线程执行任务
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true)) // true 表示创建核心线程
            return;
        c = ctl.get();
    }
    // 2. 如果当前线程数已超过核心线程数，尝试将任务放入队列
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 再次检查线程池状态，防止在offer后线程被关闭
        if (!isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0) // 如果队列不空但无工作线程，则创建一个非核心线程
            addWorker(null, false);
    }
    // 3. 如果队列已满，尝试创建非核心线程
    else if (!addWorker(command, false)) // false 表示创建非核心线程
        // 4. 如果创建非核心线程失败（已达最大线程数），则执行拒绝策略
        reject(command);
}
```

**`ctl` 字段解析**

`ctl` 是 `ThreadPoolExecutor` 中一个非常重要的 `AtomicInteger` 字段，它将线程池的状态（`RUNNING`, `SHUTDOWN`, `STOP`, `TIDYING`, `TERMINATED`）和当前工作线程数（`workerCount`）打包成一个 `int` 变量。

  * **高 3 位**：表示线程池状态。
  * **低 29 位**：表示工作线程数。
  * **设计意图：** 这种设计利用位运算，将两个信息合并到一个原子变量中，从而实现了线程池状态和工作线程数的原子性更新，避免了使用多个锁，提高了并发效率。

-----

✅ 三、常用方式 + 代码示例

**线程池的创建**

实际开发中，我们通常不直接使用 `new ThreadPoolExecutor()`，而是使用 `Executors` 工厂类提供的便捷方法，或根据实际情况自定义参数。

**1. 使用 `Executors` 工厂类**

  * **`Executors.newFixedThreadPool(int nThreads)`**

      * 核心线程数 = 最大线程数 = `nThreads`。
      * 任务队列：`LinkedBlockingQueue` (无界队列)。
      * **优点：** 线程数固定，资源消耗可控。
      * **缺点：** 队列无界，当任务过多时可能导致 **OOM (Out-Of-Memory)** 风险。**生产环境不推荐直接使用。**

  * **`Executors.newCachedThreadPool()`**

      * 核心线程数 = 0，最大线程数 = `Integer.MAX_VALUE`。
      * 任务队列：`SynchronousQueue` (不存储元素的队列)。
      * **优点：** 按需创建线程，适合处理大量短期、异步任务。
      * **缺点：** 最大线程数过大，可能创建过多线程导致资源耗尽。**生产环境不推荐直接使用。**

  * **`Executors.newSingleThreadExecutor()`**

      * 核心线程数 = 1，最大线程数 = 1。
      * 任务队列：`LinkedBlockingQueue` (无界队列)。
      * **优点：** 保证所有任务按顺序执行。
      * **缺点：** 队列无界，同 `FixedThreadPool`，有 OOM 风险。

**2. 最佳实践：手动创建线程池**

```java
import java.util.concurrent.*;

public class CustomThreadPool {
    public static void main(String[] args) {
        // 推荐手动创建，参数自定义，风险可控
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, // 核心线程数：2，即使空闲也不会被销毁
            4, // 最大线程数：4，应对任务高峰
            60L, // 线程空闲时间：60秒
            TimeUnit.SECONDS, // 时间单位
            new ArrayBlockingQueue<>(10), // 任务队列：有界队列，容量为10
            Executors.defaultThreadFactory(), // 线程工厂
            new ThreadPoolExecutor.AbortPolicy() // 拒绝策略：默认，抛出异常
        );

        // 提交15个任务
        for (int i = 0; i < 15; i++) {
            final int taskId = i;
            try {
                executor.execute(() -> {
                    System.out.println("Executing task " + taskId + " by thread: " + Thread.currentThread().getName());
                    try {
                        Thread.sleep(1000); // 模拟任务执行
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            } catch (RejectedExecutionException e) {
                System.out.println("Task " + taskId + " was rejected.");
            }
        }

        executor.shutdown(); // 优雅关闭线程池，等待所有任务执行完毕
    }
}
```

-----

🎯 四、真实面试高频问题 + 深度解析

**1. 线程池有哪些核心参数？它们的作用是什么？**

  * **标准答案：** `corePoolSize`, `maximumPoolSize`, `keepAliveTime`, `workQueue`, `threadFactory`, `rejectedExecutionHandler`。
  * **详细解析：**
      * `corePoolSize` (核心线程数)：线程池维护的最小线程数，即使空闲也不会被回收。
      * `maximumPoolSize` (最大线程数)：线程池允许创建的最大线程数。当任务队列满时，会创建新的非核心线程，直到达到这个数。
      * `keepAliveTime` (存活时间)：非核心线程在空闲时，等待任务的最长时间。超过这个时间，线程会被销毁。
      * `workQueue` (任务队列)：用于存储待处理任务的阻塞队列。常见的有 `ArrayBlockingQueue`（有界）、`LinkedBlockingQueue`（无界）、`SynchronousQueue`（不存储）。
      * `rejectedExecutionHandler` (拒绝策略)：当线程池和队列都满时，如何处理新提交的任务。有 `AbortPolicy`（抛异常）、`CallerRunsPolicy`（提交者自己执行）、`DiscardPolicy`（悄悄丢弃）、`DiscardOldestPolicy`（丢弃队列中最老的任务）。
  * **陷阱警告：** 仅仅背诵参数名称是不够的，面试官会追问这些参数之间是如何协同工作的，特别是 `corePoolSize`、`maximumPoolSize` 和 `workQueue` 之间的关系。

**2. 线程池是如何实现线程复用的？**

  * **标准答案：** 通过一个工作线程（`Worker`）类和阻塞队列（`BlockingQueue`）实现。每个 `Worker` 线程会不断地从任务队列中获取任务，然后执行，执行完毕后继续循环从队列中取任务，而不是销毁。
  * **详细解析：**
      * `ThreadPoolExecutor` 内部维护一个 `HashSet<Worker>` 集合，每个 `Worker` 是一个继承自 `AQS` 的私有内部类。
      * `Worker` 的 `run` 方法内部是一个循环，它会调用 `getTask()` 方法从 `workQueue` 中获取任务。
      * `getTask()` 方法会阻塞等待新任务。当任务到达，`getTask()` 返回该任务，然后 `Worker` 线程执行它。
      * 任务执行完毕后，`Worker` 线程的循环不会结束，而是再次调用 `getTask()`，从而实现了线程的复用。
  * **陷阱警告：** 容易误以为线程复用是简单地“执行完任务不销毁”，但更深层次的原理在于 **`Worker` 类的循环** 和 **`BlockingQueue` 的阻塞等待机制**。

**3. `Executors` 创建的线程池有什么问题？生产环境为什么不推荐使用？**

  * **标准答案：** `newFixedThreadPool` 和 `newSingleThreadExecutor` 使用了无界队列 `LinkedBlockingQueue`，当任务提交过快时，可能导致队列中堆积大量任务，引发 OOM；`newCachedThreadPool` 的 `maximumPoolSize` 是 `Integer.MAX_VALUE`，当任务提交速度远大于执行速度时，可能创建过多线程，导致系统资源耗尽。
  * **详细解析：** 生产环境的任务量通常难以预估，使用无界队列或无限扩容的线程池存在巨大的资源风险。
      * `newFixedThreadPool`：队列无界 -\> 任务无限堆积 -\> 内存溢出。
      * `newCachedThreadPool`：线程数无界 -\> 创建过多线程 -\> 争抢资源，CPU 频繁切换 -\> 性能急剧下降，甚至系统崩溃。
  * **陷阱警告：** 面试官会考察你是否理解“无界队列”和“无限线程”带来的具体风险，以及如何通过手动创建线程池来规避这些问题。

**4. 线程池的拒绝策略有哪些？**

  * **标准答案：**
    1.  `AbortPolicy` (默认)：直接抛出 `RejectedExecutionException` 异常。
    2.  `CallerRunsPolicy`：不抛弃任务，而是由提交任务的线程（caller）自己来执行这个任务。
    3.  `DiscardPolicy`：直接丢弃该任务，不抛出任何异常。
    4.  `DiscardOldestPolicy`：丢弃队列中等待最久的那个任务，然后尝试重新提交新任务。
  * **详细解析：**
      * `AbortPolicy` 最激进，适合对任务完整性要求高但可能需要外部重试的场景。
      * `CallerRunsPolicy` 是一种“降级”策略，将压力反向传递给调用方，防止任务丢失，同时减缓提交速度。
      * `DiscardPolicy` 最佛系，适合那些对结果不那么敏感，允许丢失一部分任务的场景。
      * `DiscardOldestPolicy` 是一种有选择性的丢弃，适合那些“新任务比老任务更重要”的场景。

**5. `execute()` 和 `submit()` 有什么区别？**

  * **标准答案：** `execute()` 用于提交 `Runnable` 任务，没有返回值；`submit()` 可以提交 `Runnable` 或 `Callable` 任务，并返回一个 `Future` 对象，通过 `Future` 可以获取任务执行结果，或取消任务。
  * **详细解析：**
      * `execute()` 提交的任务，若抛出异常，线程池会捕获并打印堆栈信息。
      * `submit()` 提交的任务，若抛出异常，异常会被 `Future` 对象封装，**不会直接在控制台打印**。需要调用 `Future.get()` 方法时才会抛出异常。
  * **陷阱警告：** 许多开发者不知道 `submit()` 提交任务时的异常处理机制，如果任务失败但没有调用 `get()`，异常就会被“吞掉”，导致排查问题困难。

-----

💡 五、口诀 + 表格/图示辅助记忆

**线程池工作流程口诀**

> **一核心，二队列，三救火，四拒绝。**
>
> 1.  **一核心：** 先看核心线程数，不满就创建。
> 2.  **二队列：** 核心已满，任务入队列。
> 3.  **三救火：** 队列已满，创建非核心“救火”线程。
> 4.  **四拒绝：** 所有都满，执行拒绝策略。

**线程池状态流转图**

```
                  +-----------------+
                  |      RUNNING    |
                  |  (接受任务、处理队列) |
                  +--------|--------+
                           | shutdown()
                           |
            +--------------v--------------+
            |          SHUTDOWN           |
            |     (不再接受新任务, 但处理队列中任务) |
            +--------------|--------------+
                           |
                  (队列为空且工作线程数为0)
                           |
            +--------------v--------------+
            |           TIDYING           |
            |       (所有任务已完成)        |
            +--------------|--------------+
                           | terminate()
                           |
                  +--------v--------+
                  |     TERMINATED  |
                  | (线程池完全终止) |
                  +-----------------+
```

-----

🎁 六、建议 + 误区提醒

**误区提醒**

1.  **滥用 `Executors` 工厂类：** 永远不要在生产环境直接使用 `Executors` 创建的线程池，特别是 `newFixedThreadPool` 和 `newCachedThreadPool`。自定义线程池参数，才能让资源风险可控。
2.  **错误理解 `submit()` 异常：** `submit()` 提交的任务若发生异常，需要显式调用 `Future.get()` 才能捕获。否则，异常会被忽略，导致线上问题难以排查。
3.  **盲目设置过大的线程数：** 线程数并非越多越好。**CPU 密集型任务** 的线程数应接近 **CPU 核心数** (`N + 1`)，**IO 密集型任务** 的线程数可以设置得大一些 (`2N` 或更高)，以充分利用 IO 等待时间。

**使用建议**

1.  **优先使用 `ThreadPoolExecutor` 自定义参数：**
      * **核心线程数**：根据任务类型和系统负载评估，可以设置为 **`CPU核心数 * 2`** 或更小。
      * **最大线程数**：设置一个合理的上限，防止任务突增导致创建过多线程。
      * **任务队列**：优先使用 **有界队列** (`ArrayBlockingQueue`)，并通过调整队列大小来控制任务积压。
2.  **优雅关闭线程池：**
      * 使用 `shutdown()` 方法，它会等待所有已提交的任务执行完毕，但不再接受新任务。
      * 使用 `shutdownNow()` 方法，它会尝试停止所有正在执行的任务，并返回未执行的任务列表，但可能导致任务丢失。
3.  **为线程池命名：** 在自定义 `ThreadFactory` 时，为线程池的线程加上有意义的名字（如 `order-worker-1`），方便在日志和线程 Dump 中定位问题。