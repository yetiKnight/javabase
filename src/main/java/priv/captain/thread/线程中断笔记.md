-----

### 📘 Java 并发复习笔记：线程中断

### ✅ 一、概念简介

**线程中断是什么？**

线程中断是 Java 中一种线程间**协作式**的通知机制。当一个线程需要通知另一个线程停止其当前工作或改变其行为时，它不是直接强制终止目标线程，而是**发送一个中断信号**。

可以把线程中断想象成\*\*“温柔的提醒”\*\*：

  - 你想让同事暂停工作去开会。你不会直接关掉他的电脑（强制终止），而是拍拍他的肩膀，告诉他“该开会了”。
  - 同事收到提醒后，会根据自己的情况，选择是马上停下工作，还是等手头的事情做完再走。

**核心思想：**

  - 发送中断信号是一个**请求**，而不是一个命令。
  - 目标线程有权**决定如何响应**这个中断请求。
  - 开发者必须在代码中显式地**处理**这个中断信号。

-----

### 🔹 二、核心方法

Java 提供了三个与线程中断相关的核心方法，它们都在 `Thread` 类中：

1.  **`Thread.interrupt()`：**
      * **作用**：向目标线程发送中断信号。
      * **效果**：
          * 如果目标线程处于**阻塞状态**（如 `wait()`, `sleep()`, `join()`），它会立即**抛出 `InterruptedException`**，并清除中断状态（将中断标志位设为 `false`）。
          * 如果目标线程处于**运行状态**，它不会有任何变化，只是将线程的中断标志位设为 `true`。
2.  **`Thread.isInterrupted()`：**
      * **作用**：**判断**目标线程的中断标志位是否为 `true`。
      * **效果**：返回布尔值，但**不会清除**中断标志位。
3.  **`Thread.interrupted()`：**
      * **作用**：**判断**当前线程的中断标志位是否为 `true`，并**清除**中断标志位。
      * **效果**：返回布尔值，并将中断标志位设为 `false`。这是一个静态方法，总是返回**当前线程**的中断状态。

-----

### 🔹 三、线程中断的两种场景与处理

#### 1\. 响应阻塞中断（`InterruptedException`）

这是最常见的场景。当线程调用会抛出 `InterruptedException` 的方法时，如果收到中断信号，它会立即从阻塞状态中醒来，并抛出异常。

```java
public class InterruptedExample {
    public static void main(String[] args) {
        Thread worker = new Thread(() -> {
            try {
                System.out.println("Worker: 我开始工作了...");
                // 模拟一个耗时阻塞操作
                Thread.sleep(5000); 
                System.out.println("Worker: 阻塞操作完成。");
            } catch (InterruptedException e) {
                // 收到中断信号，抛出异常，并进入 catch 块
                System.out.println("Worker: 收到中断信号，我被中断了！");
                // 这里的处理非常重要！
                // 1. 优雅退出：如果你想让线程结束，直接 return 即可。
                // return; 
                
                // 2. 继续工作：如果你想继续工作，需要重新设置中断标志
                // 因为异常会清除标志位
                Thread.currentThread().interrupt(); 
            }
        });

        worker.start();
        
        try {
            // 主线程等待一段时间，然后中断 worker 线程
            Thread.sleep(1000);
            System.out.println("Main: 我来中断 worker 线程...");
            worker.interrupt();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

  * **处理要点：**
      * 在 `catch (InterruptedException e)` 块中，**中断标志位已经被清除**。
      * 如果你希望调用栈上层的方法也能感知到中断，**必须手动调用 `Thread.currentThread().interrupt()` 重新设置中断标志**。
      * 如果你不重新设置，上层代码再调用 `isInterrupted()` 时，会得到 `false`。

#### 2\. 响应非阻塞中断（`isInterrupted()`）

当线程执行一段长时间运行的代码，且不涉及阻塞方法时，你需要定期检查中断标志位来决定是否终止。

```java
public class NonBlockingInterruptedExample {
    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                // 模拟耗时任务
                System.out.println("Worker: 我正在努力工作...");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    // 当 sleep() 抛出异常时，中断标志位已经被清除了
                    System.out.println("Worker: 阻塞被中断，退出循环。");
                    // 重新设置中断标志，让循环条件生效
                    Thread.currentThread().interrupt(); 
                }
            }
            System.out.println("Worker: 循环结束，我退出了！");
        });

        worker.start();
        
        Thread.sleep(2000);
        System.out.println("Main: 我来中断 worker 线程...");
        worker.interrupt();
    }
}
```

  * **处理要点：**
      * 在循环中，使用 `!Thread.currentThread().isInterrupted()` 作为循环条件。
      * 如果循环体内部有阻塞方法（如 `sleep`），必须在 `catch` 块中**重新设置中断标志**，否则循环条件将永远不会变为 `false`。

-----

### 🔍 四、面试高频问题 + 深度解析

**1. `Thread.interrupt()` 会强制终止线程吗？**

  * **标准答案：** 不会。`interrupt()` 只是发送一个中断信号，是一种**协作式**的通知机制。线程有权决定如何响应这个信号，它既可以立即停止，也可以继续运行。

**2. `interrupted()` 和 `isInterrupted()` 有什么区别？**

  * **标准答案：**
      * **`interrupted()`：** 是一个**静态方法**，检查**当前线程**的中断标志位，并且会**清除**标志位（`true` -\> `false`）。
      * **`isInterrupted()`：** 是一个**实例方法**，检查**指定线程**的中断标志位，但**不会清除**标志位。

**3. 为什么在 `catch (InterruptedException e)` 中要重新设置中断标志？**

  * **标准答案：** 当一个阻塞方法（如 `sleep()`）抛出 `InterruptedException` 时，它会自动将线程的中断标志位清除。如果你不重新设置，调用栈上层的方法将无法感知到中断，这可能导致逻辑错误。重新设置后，上层代码可以通过 `isInterrupted()` 来判断并处理中断。

**4. 线程中断有什么好的实践方式？**

  * **标准答案：**
    1.  **不要滥用中断：** 除非你真的想终止线程，否则不要使用 `interrupt()`。
    2.  **遵循协作原则：** 永远不要强制终止一个线程，而是通过中断机制来让线程优雅地停止。
    3.  **在 `finally` 块中处理资源：** 即使线程被中断，`finally` 块中的代码也总是会执行，可以用来关闭资源、释放锁等。
    4.  **在 `InterruptedException` 中恢复中断状态：** 这是最关键的实践之一，避免中断信号丢失。

-----

### 🎁 总结与建议

  * **线程中断不是“杀手”，而是“信使”。** 它通过设置一个标志位，来请求线程停止。
  * 理解 `interrupt()`、`interrupted()` 和 `isInterrupted()` 的区别，是掌握线程中断的关键。
  * 在实际项目中，使用中断来优雅地停止线程（如关闭服务、取消任务），是比 `stop()` 方法更安全、更推荐的做法。`Thread.stop()` 因为不安全，已经被废弃了。