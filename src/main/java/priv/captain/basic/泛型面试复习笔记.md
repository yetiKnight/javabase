### 📘 Java 面试复习笔记：泛型 (Generics)

### ✅ 一、概念简介

**泛型是什么？**

泛型，即 Generics，是 JDK 5 引入的一项强大特性。它实现了**参数化类型**，允许在定义类、接口和方法时，使用一个或多个**类型参数**（Type Parameters），从而使得代码可以适用于多种数据类型，而不是固定为某一种。

可以把泛型想象成一个\*\*“类型占位符”\*\*：

  - 你在写代码时，先用一个占位符 `T` 来代替具体的类型。
  - 当你使用这个类或方法时，再用实际的类型（比如 `String` 或 `Integer`）替换这个占位符。

**为什么用？**

🎯 **核心目的：** 提高代码的**类型安全**、**复用性**和**可读性**。

  * **类型安全（Type Safety）：** 泛型在编译时进行类型检查，可以捕获潜在的类型转换错误，避免在运行时抛出 `ClassCastException`。
  * **消除强制类型转换（Casting）：** 使用泛型后，编译器会为我们自动进行类型转换，从而消除了代码中的强制类型转换，使代码更简洁、更可读。
  * **代码复用（Code Reusability）：** 泛型可以编写适用于多种类型的通用代码，减少了为每种类型编写重复代码的需要。

-----

### 🔹 二、核心概念与原理

#### 1\. 泛型的使用

泛型可以用于三个地方：

  * **泛型类：** 在类名后面加上 `<T>`，`T` 是类型参数。

    ```java
    class Box<T> {
        private T data;
        public Box(T data) { this.data = data; }
        public T getData() { return data; }
    }
    // 使用
    Box<String> stringBox = new Box<>("Hello");
    ```

  * **泛型接口：** 在接口名后面加上 `<T>`。

    ```java
    interface Generator<T> {
        T next();
    }
    // 实现
    class FruitGenerator implements Generator<String> {
        public String next() { return "Apple"; }
    }
    ```

  * **泛型方法：** 在方法返回类型前面加上 `<T>`。

    ```java
    public <T> T getFirst(List<T> list) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }
    ```

#### 2\. 类型擦除 (Type Erasure)

这是泛型的一个核心原理，也是面试高频考点。

  * **什么是类型擦除？** 泛型信息只存在于**编译时**，在编译后（生成 `.class` 文件时）会被**擦除**，替换为它们的**限定类型**（通常是 `Object`）。
  * **为什么进行类型擦除？** 这是为了**向后兼容**，使得 Java 5 引入的泛型代码能够与之前版本的 Java 虚拟机（不识别泛型）兼容。
  * **类型擦除的后果：**
    1.  **无法在运行时获取泛型类型信息。** 例如，`new ArrayList<String>().getClass() == new ArrayList<Integer>().getClass()` 返回 `true`，因为它们在运行时都是 `ArrayList`。
    2.  **不能创建泛型类型的实例。** 例如 `new T()` 是非法的。
    3.  **泛型类的静态变量不能是泛型类型。** 因为静态变量是所有实例共享的，而泛型类型在运行时被擦除为 `Object`，无法确定具体类型。

### 🔹 三、泛型的通配符

为了解决泛型类型之间的兼容性问题，Java 引入了泛型通配符。

  * **无界通配符 `<?>`：** 代表任何类型。例如 `List<?>` 可以引用 `List<String>` 或 `List<Integer>`，但不能添加任何元素（`null` 除外），因为它无法确定类型。

  * **上界通配符 `<? extends T>`：** 代表类型 `T` 及其子类。

      * **读数据安全：** 你可以从 `List<? extends Fruit>` 中安全地**读取** `Fruit` 类型的对象。
      * **写数据不安全：** 你不能向 `List<? extends Fruit>` 中**添加**任何 `Fruit` 的子类型，因为编译器无法确定具体类型。例如，如果 `List` 实际上是 `List<Apple>`，那么添加 `Orange` 会导致类型不匹配。
      * **PECS 原则 (Producer Extends, Consumer Super)：** 当一个泛型类作为**生产者**（向外提供数据）时，使用 `<? extends T>`。

  * **下界通配符 `<? super T>`：** 代表类型 `T` 及其父类。

      * **读数据不安全：** 你从 `List<? super Apple>` 中**读取**到的对象，只能被当作 `Object` 处理，因为你不知道它是 `Apple` 的哪个父类。
      * **写数据安全：** 你可以向 `List<? super Apple>` 中**添加** `Apple` 或其任何子类型，因为它们都是 `Apple` 的父类的子类，类型匹配。
      * **PECS 原则：** 当一个泛型类作为**消费者**（向内接收数据）时，使用 `<? super T>`。

### 🔹 四、泛型的约束

  * **类型参数的约束：**

      * `class MyClass<T extends Number>`：限制类型参数 `T` 必须是 `Number` 及其子类。
      * `class MyClass<T extends Runnable & Cloneable>`：`&` 用于指定多个接口约束。

  * **泛型方法的约束：**

      * `<T extends Comparable<T>> T findMax(T a, T b)`：限制类型参数 `T` 必须实现 `Comparable` 接口，并且能够与自身进行比较。

-----

### 🔍 五、真实面试高频问题 + 深度解析

**1. 什么是泛型？有什么好处？**

  * **标准答案：** 泛型是参数化类型，允许在定义时使用类型参数。好处包括类型安全、消除强制类型转换和代码复用。

**2. 什么是类型擦除？它有什么优缺点？**

  * **标准答案：** 类型擦除是 Java 泛型在编译时将类型信息擦除为 `Object` 的机制。
  * **优点：** 向后兼容性，使得旧的 JVM 也能运行泛型代码。
  * **缺点：** 运行时无法获取泛型类型信息，导致一些功能受限，如不能用 `instanceof` 判断泛型类型，不能创建泛型数组 `new T[10]`。

**3. 泛型通配符 `?`、`? extends T`、`? super T` 有什么区别？**

  * **标准答案：**
      * `?`：无界通配符，表示任意类型，不可写入。
      * `? extends T`：上界通配符，表示 `T` 或 `T` 的子类型，只可读不可写（生产者）。
      * `? super T`：下界通配符，表示 `T` 或 `T` 的父类型，只可写不可读（消费者）。
  * **PECS 原则：** 这是通配符使用的最佳实践。`Producer Extends`（生产者用 `extends`），`Consumer Super`（消费者用 `super`）。

**4. 泛型方法和泛型类有什么区别？**

  * **标准答案：**
      * **泛型类：** 泛型类型是在类实例化时指定的。例如 `new Box<String>()`。
      * **泛型方法：** 泛型类型是在调用方法时指定的，可以独立于其所在的类。
  * **注意点：** 泛型方法即使在非泛型类中也可以定义，它的类型参数 `<T>` 独立于类的类型参数。

### 💡 六、口诀 + 表格/图示辅助记忆

**通配符口诀**

> **上界 `extends`，只能取。**
> **下界 `super`，只能存。**
> **生产者 `extends`，消费者 `super`。**

**泛型核心概念对比**

| 特性 | **泛型** | **类型擦除后** |
| :--- | :--- | :--- |
| **编译时** | 存在类型参数 `T` | 存在类型参数 `T` |
| **运行时** | `Object` | `Object` |
| **类型安全** | 编译时检查 | 运行时抛出异常 |
| **泛型信息**| 保留 | 丢失 |

### 🎁 七、建议 + 误区提醒

**误区提醒**

1.  **认为泛型是运行时概念：** 泛型信息只在编译时存在，运行时被擦除。这是最容易混淆的一点。
2.  **认为 `List<String>` 是 `List<Object>` 的子类：** 尽管 `String` 是 `Object` 的子类，但 `List<String>` 和 `List<Object>` 之间**没有继承关系**。

**使用建议**

1.  **善用通配符：** 在设计 API 时，使用 `<? extends T>` 和 `<? super T>` 能使你的 API 更加灵活和通用。
2.  **避免强制类型转换：** 泛型的核心目的就是消除强制类型转换，如果你在代码中发现大量的 `(Type)` 转换，很可能你的泛型设计有问题。
3.  **泛型数组：** 泛型数组是不能直接创建的，例如 `new T[10]`。你可以创建通用的 `Object[]` 数组，然后在方法内部进行类型转换。