### 📘 Java Web 复习笔记：过滤器 vs. 拦截器

### ✅ 一、概念简介

在 Java Web 开发中，过滤器和拦截器都是在请求到达目标资源之前或之后，执行特定逻辑的组件。它们的作用相似，但**工作层面、技术实现和应用场景**有很大不同。

| 特性 | **过滤器（Filter）** | **拦截器（Interceptor）** |
| :--- | :--- | :--- |
| **工作层面**| Servlet 容器层面 | Spring 框架层面 |
| **底层实现**| 基于函数回调（`FilterChain`） | 基于反射（Java 的 `Method`） |
| **依赖关系**| 不依赖于 Spring 框架 | 依赖于 Spring 框架 |
| **拦截范围**| 几乎可以拦截所有请求 | 只能拦截对 Controller 的请求 |
| **生命周期**| Servlet 容器创建、管理 | Spring 容器创建、管理 |
| **核心用途**| 通用的预处理，如编码、压缩、权限检查、XSS 过滤 | 精细化的请求处理，如日志记录、事务管理、权限检查 |

### 🔹 二、过滤器（Filter）

#### 1. 工作原理

过滤器是基于 **Servlet 规范**的。当请求到达 Servlet 容器（如 Tomcat）时，会首先进入过滤器链（`FilterChain`）。每个过滤器都有机会在请求进入 Servlet 之前或从 Servlet 返回后进行处理。

* **核心接口：** `javax.servlet.Filter`
* **核心方法：**
    * `init(FilterConfig filterConfig)`：在过滤器实例化后调用，用于初始化。
    * `doFilter(ServletRequest request, ServletResponse response, FilterChain chain)`：**核心方法**。在这里实现业务逻辑。通过调用 `chain.doFilter()`，将请求传递给下一个过滤器或目标资源。
    * `destroy()`：在容器卸载过滤器时调用，用于释放资源。

#### 2. 典型应用场景

* **字符编码统一**：这是最经典的用法，将所有请求的编码统一设置为 UTF-8。
* **权限控制**：检查用户是否登录或拥有特定权限，如果未通过，直接返回或重定向。
* **数据过滤**：防止 SQL 注入、XSS 攻击。
* **日志记录**：记录所有请求的访问日志。
* **压缩响应**：对响应数据进行压缩，减少网络传输量。

---

### 🔹 三、拦截器（Interceptor）

#### 1. 工作原理

拦截器是 **Spring 框架**提供的功能。它在 DispatcherServlet 将请求分发给 Controller 之前，提供了一种处理请求的机制。

* **核心接口：** `org.springframework.web.servlet.HandlerInterceptor`
* **核心方法：**
    * `preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)`：**前置处理**。在请求发送给 Controller 之前执行。如果返回 `false`，则中断后续流程。
    * `postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)`：**后置处理**。在 Controller 方法执行之后，但在视图渲染之前执行。可以修改 `ModelAndView`。
    * `afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)`：**完成处理**。在整个请求处理完成（包括视图渲染）之后执行，通常用于资源清理。

#### 2. 典型应用场景

* **日志记录**：记录 Controller 方法的执行时间。
* **登录验证**：在 Controller 方法执行前，检查用户是否已登录。
* **权限校验**：检查用户是否有访问特定 Controller 的权限。
* **事务管理**：在方法执行前开启事务，结束后提交或回滚。
* **数据缓存**：根据特定的规则进行缓存处理。

---

### 🔍 四、面试高频问题 + 深度解析

**1. 过滤器和拦截器有什么区别？**

* **标准答案：**
    1.  **归属不同**：过滤器是 Servlet 规范的，拦截器是 Spring 框架的。
    2.  **工作层级不同**：过滤器在 Servlet 容器层面工作，拦截器在 Spring MVC 框架层面工作。
    3.  **拦截范围不同**：过滤器可以拦截几乎所有请求（包括 JSP、HTML、图片等），而拦截器只能拦截对 Controller 的请求。
    4.  **调用顺序不同**：通常情况下，过滤器先于拦截器执行。
    5.  **依赖关系不同**：过滤器不依赖于 Spring，拦截器必须在 Spring 环境中使用。

**2. 过滤器和拦截器的执行顺序是怎样的？**

* **标准答案：** 当一个请求进入 Spring MVC 应用时，其执行顺序是：
    * **过滤器 `doFilter` 前半部分** -> **拦截器 `preHandle`** -> **Controller** -> **拦截器 `postHandle`** -> **拦截器 `afterCompletion`** -> **过滤器 `doFilter` 后半部分**。
    * 总结来说：**`Filter` -> `Interceptor` -> `Controller` -> `Interceptor` -> `Filter`**。

**3. 如何选择使用过滤器还是拦截器？**

* **标准答案：**
    * **使用过滤器**：当你需要处理**通用的、与具体业务无关的**请求预处理时，比如统一字符编码、防止 XSS 攻击等。这些操作通常在 Servlet 容器级别完成，不依赖于 Spring。
    * **使用拦截器**：当你需要对**Controller 层的业务逻辑**进行精细化控制时，比如权限校验、日志记录、性能监控、事务管理等。这些操作通常需要访问 Spring 容器中的 Bean。

**4. 拦截器和 AOP 有什么区别？**

* **标准答案：**
    * **拦截器**：针对 **Web 请求**，工作在 **Controller 层**。
    * **AOP (面向切面编程)**：是一种通用的编程思想，可以应用于**任何方法**的调用。它通过动态代理等技术，在方法执行前、后、异常时插入自定义代码。
    * **总结**：拦截器是 AOP 在 Web 层的一种具体应用。AOP 的能力更强大，拦截器更专注于 Web 请求的拦截。

---

### 🎁 总结与建议

* 过滤器和拦截器都是实现**请求链式处理**的重要组件。
* 记住它们最大的区别在于**工作层级**：过滤器在 Servlet 容器，拦截器在 Spring 框架。
* 在实际项目中，通常会**两者结合使用**：用过滤器处理通用的、粗粒度的任务；用拦截器处理更精细、与 Spring Bean 相关的任务。