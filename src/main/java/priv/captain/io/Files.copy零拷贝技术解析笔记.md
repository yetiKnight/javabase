要解析 `Files.copy` 的零拷贝技术，我们得先了解传统的I/O操作是如何工作的，然后才能明白零拷贝为什么如此高效。

### 传统 I/O 的文件复制

传统的 I/O 操作，比如使用 `FileInputStream` 和 `FileOutputStream` 复制文件，通常需要经过4次数据拷贝和2次模式切换（用户态与内核态的切换）。

1.  **第一次拷贝：** 操作系统将数据从磁盘读取到**内核缓冲区**。
2.  **第一次模式切换：** JVM 调用 `read()` 方法，从内核态切换到用户态。
3.  **第二次拷贝：** 操作系统将数据从内核缓冲区复制到 JVM 进程的**用户缓冲区**（Java 里的 `byte[]` 数组）。
4.  **第二次模式切换：** JVM 调用 `write()` 方法，从用户态切换到内核态。
5.  **第三次拷贝：** 操作系统将数据从用户缓冲区复制到**内核缓冲区**（`socket buffer` 或 `file buffer`）。
6.  **第四次拷贝：** 操作系统将数据从内核缓冲区写到磁盘或网络接口。

这个过程就像是数据在不同内存区域之间来回倒腾，每次倒腾都伴随着CPU的上下文切换，效率自然不高。

---

### `Files.copy` 和零拷贝技术

`Files.copy` 在底层（特别是在 Linux 系统上）通常会利用操作系统的**零拷贝（Zero-copy）技术**。这种技术旨在减少甚至消除不必要的CPU拷贝和上下文切换。

它主要通过一种叫做 `sendfile` 的系统调用来实现。`sendfile` 系统调用在内核中完成了整个数据传输过程，从而避免了数据在用户缓冲区和内核缓冲区之间的来回拷贝。

这是一个简化的零拷贝过程：

1.  **第一次拷贝：** 操作系统将数据从磁盘读取到**内核缓冲区**。
2.  **不进行模式切换：** 数据停留在内核态，没有被复制到用户态。
3.  **第二次拷贝（仅描述符）：** 操作系统直接将数据从内核缓冲区（`page cache`）复制到目标文件或网络接口的内核缓冲区，整个过程在内核中完成。
4.  **完成：** 数据直接从内核流向目标，没有经过用户缓冲区。

通过这个过程，我们成功减少了两次数据拷贝和两次模式切换。数据不再需要经过 JVM 进程的堆内存，大大提高了效率。

---

### 总结

- **传统 I/O：** 4次拷贝，2次模式切换。数据在内核态和用户态之间“旅行”，CPU开销大。
- **`Files.copy`（零拷贝）：** 2次拷贝，0次模式切换。数据始终在内核态中传输，CPU开销小，性能高。

`Files.copy` 能够高效工作的原因在于，它将文件复制的指令直接交给了操作系统内核，让内核来全权处理这个任务，而不是让JVM作为中间人来传递数据。这使得 `Files.copy` 成为处理文件I/O时最简单、最高效的通用方法之一。