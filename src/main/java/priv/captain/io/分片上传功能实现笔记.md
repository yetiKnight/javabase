---

# 📌 分片上传功能复习笔记

---

## 1️⃣ 数据库设计（三张表）

### 1.1 物理文件存储表 `file_storage`

| 字段名           | 类型            | 说明                   |
| ------------- | ------------- | -------------------- |
| id            | bigint / uuid | 主键                   |
| file\_md5     | varchar       | 文件唯一标识（用于去重）         |
| file\_name    | varchar       | 文件名                  |
| file\_size    | bigint        | 文件大小                 |
| file\_path    | varchar       | 文件存储路径               |
| status        | tinyint       | 文件状态（0: 上传中，1: 上传完成） |
| gmt\_create   | datetime      | 创建时间                 |
| gmt\_modified | datetime      | 更新时间                 |

**说明：**

* 用于存储实际的物理文件信息
* 文件去重通过 `file_md5` 实现

---

### 1.2 用户文件关系表 `user_file`

| 字段名                  | 类型            | 说明                     |
| -------------------- | ------------- | ---------------------- |
| id                   | bigint / uuid | 主键                     |
| user\_id             | bigint        | 用户 ID                  |
| file\_id             | bigint        | 对应 `file_storage` 的 id |
| original\_file\_name | varchar       | 用户上传的原始文件名             |
| gmt\_create          | datetime      | 创建时间                   |

**说明：**

* 支持同一文件被多个用户上传，避免重复存储
* 保存用户与文件的关系

---

### 1.3 分片记录表 `file_chunk`

| 字段名           | 类型            | 说明                  |
| ------------- | ------------- | ------------------- |
| id            | bigint / uuid | 主键                  |
| file\_md5     | varchar       | 文件唯一标识              |
| chunk\_index  | int           | 分片索引                |
| chunk\_size   | bigint        | 分片大小                |
| status        | tinyint       | 分片状态（0: 未上传，1: 已上传） |
| gmt\_create   | datetime      | 创建时间                |
| gmt\_modified | datetime      | 更新时间                |

**说明：**

* 记录每个分片上传状态
* 支持断点续传

---

## 2️⃣ 文件存储目录结构

**临时分片目录：**

```
/tmp/upload/{fileMd5}_{userId}/{chunkIndex}
```

* `{fileMd5}_{userId}` 用作分片目录，避免不同用户冲突
* 分片上传完成后，合并到最终目录：

```
/final/path/{fileMd5}
```

* **合并规则**：同一个 `fileMd5` 只允许一个合并操作

---

## 3️⃣ 分片上传前后端流程

### 3.1 前端流程

1. 选择文件，计算 MD5
2. 分片切割
3. 上传前调用 `/checkUploadedChunks?fileMd5=xxx&userId=xxx`
4. 遍历分片上传（跳过已上传分片）
5. 上传完成后调用 `/mergeChunks?fileMd5=xxx&userId=xxx`

```ts
const tempDir = `${fileMd5}_${userId}`;
for (let i = 0; i < totalChunks; i++) {
    if (uploadedChunks.includes(i)) continue;
    const chunk = file.slice(i * chunkSize, (i + 1) * chunkSize);
    await uploadChunk(chunk, i, totalChunks, fileMd5, userId);
}
await mergeChunks(fileMd5, userId);
```

---

### 3.2 后端逻辑

#### 上传分片接口 `/uploadChunk`

```java
@PostMapping("/uploadChunk")
public Result uploadChunk(MultipartFile fileChunk, String fileMd5, int chunkIndex, Long userId) {
    String tempDir = "/tmp/upload/" + fileMd5 + "_" + userId + "/";
    saveFile(fileChunk, tempDir + chunkIndex);
    markChunkUploaded(fileMd5, chunkIndex); // 更新 file_chunk 表
    return success();
}
```

#### 合并分片接口 `/mergeChunks`（使用 Redis 分布式锁）

```java
@PostMapping("/mergeChunks")
public Result mergeChunks(String fileMd5) {
    String lockKey = "merge_lock:" + fileMd5;
    if (!redisLock.tryLock(lockKey, 30)) {
        return fail("文件正在合并中");
    }
    try {
        List<File> chunks = getAllChunks(fileMd5); // 只根据 fileMd5，不区分 userId
        try (FileOutputStream out = new FileOutputStream("/final/path/" + fileMd5)) {
            for (File chunk : chunks) {
                Files.copy(chunk.toPath(), out);
            }
        }
        deleteTempChunks(fileMd5); // 删除临时目录
        markFileCompleted(fileMd5); // 更新 file_storage 表
    } finally {
        redisLock.unlock(lockKey);
    }
    return success();
}
```

#### 查询已上传分片 `/checkUploadedChunks`

```java
@GetMapping("/checkUploadedChunks")
public List<Integer> checkUploadedChunks(String fileMd5, Long userId) {
    return getUploadedChunksFromDb(fileMd5, userId);
}
```

---

## 4️⃣ 注意事项（补充）

1. **Redis 分布式锁**

   * 保证同一个 `fileMd5` 只会有一个合并操作
   * 避免并发合并导致文件损坏

2. **用户隔离**

   * 临时目录使用 `{fileMd5}_{userId}`，保证不同用户上传同一文件不会冲突

3. **分片状态**

   * `file_chunk.status = 1` 表示上传成功
   * 合并前检查所有分片状态

4. **文件去重**

   * 合并完成后只存储一个物理文件
   * 多个用户共享同一 `file_md5` 对应的文件

5. **异常处理**

   * 上传失败可重试
   * 合并失败可重新加锁执行
   * 定期清理超时临时目录

---