好的，让我们来系统地复习 JVM。

-----

### 📘 Java 面试复习笔记：JVM（Java 虚拟机）

### ✅ 一、概念简介

**JVM 是什么？**

JVM (Java Virtual Machine) 是 Java 语言的运行环境。它是一个**抽象的计算机器**，负责将 Java 字节码（.class 文件）转换为特定操作系统的机器码并执行。JVM 屏蔽了底层硬件和操作系统的差异，从而实现了 Java 语言\*\*“一次编写，到处运行”\*\*的跨平台特性。

**JVM 的核心作用**

  * **字节码执行器：** 负责加载、验证和执行 `.class` 文件中的字节码指令。
  * **内存管理：** 划分和管理运行时内存，包括堆、栈、方法区等，并负责垃圾回收（GC）。
  * **类加载：** 动态加载所需的类文件。

-----

### 🔹 二、JVM 内存区域

JVM 内存区域是面试的重点，你可以把它分为**线程共享**和**线程私有**两部分。

#### 1\. 线程私有（随线程生，随线程灭）

  * **程序计数器（Program Counter Register）：**

      * 一块非常小的内存空间，是**唯一**不会出现 `OutOfMemoryError` 的区域。
      * 作用是存储当前线程正在执行的字节码指令的地址。
      * 在多线程环境下，每个线程都需要独立的程序计数器来记录自己的执行位置，因此它是线程私有的。

  * **Java 虚拟机栈（Java Virtual Machine Stacks）：**

      * 用于存储**局部变量**、方法参数、返回地址等信息。
      * 每个方法被执行时，JVM 都会为其创建一个**栈帧（Stack Frame）**，栈帧随着方法的调用而入栈，随着方法的执行完毕而出栈。
      * 如果栈的深度超过了 JVM 允许的范围，会抛出 `StackOverflowError`。

  * **本地方法栈（Native Method Stacks）：**

      * 与虚拟机栈类似，但它为**Native 方法**（由 C/C++ 编写）服务。

#### 2\. 线程共享（随虚拟机生，随虚拟机灭）

  * **堆（Heap）：**

      * JVM 内存中**最大**的一块区域，是所有线程共享的。
      * 用于存放**几乎所有对象实例**和数组。
      * 是\*\*垃圾回收（GC）\*\*的主要区域，分为新生代（Young Generation）和老年代（Old Generation）。
      * 如果堆中没有内存完成实例分配，并且垃圾回收器也无法回收足够的内存，会抛出 `OutOfMemoryError`。

  * **方法区（Method Area）：**

      * 用于存储已被虚拟机加载的**类信息、常量、静态变量、即时编译器（JIT）编译后的代码**等。
      * 在 JDK 1.8 之前，方法区被称为**永久代（PermGen）**，在 JDK 1.8 之后，永久代被\*\*元空间（Metaspace）\*\*取代。
      * 元空间不再在 JVM 内存中，而是使用本地内存，因此默认情况下不会发生 `OutOfMemoryError`，但如果元空间分配的内存耗尽，也会抛出异常。

### 🔹 三、类加载机制

JVM 的类加载机制是动态的，它在运行时将`.class`文件加载到内存中。

  * **加载（Loading）：** 通过类的完全限定名，查找并加载字节码文件，并将其转换为方法区的运行时数据结构。
  * **验证（Verification）：** 确保`.class`文件的字节流符合 JVM 规范，没有安全问题。
  * **准备（Preparation）：** 为类变量（`static` 变量）分配内存，并设置默认初始值（例如 `int` 初始为 0）。
  * **解析（Resolution）：** 将常量池中的符号引用替换为直接引用。
  * **初始化（Initialization）：** 执行类构造器`<clinit>()`方法，为类变量赋予真正的值（例如 `static int i = 10`），并执行静态代码块。

#### **类加载器（ClassLoader）**

JVM 内置了三种类加载器：

1.  **启动类加载器（Bootstrap ClassLoader）：** 负责加载 `JAVA_HOME/jre/lib` 目录下的核心类库。
2.  **扩展类加载器（Extension ClassLoader）：** 负责加载 `JAVA_HOME/jre/lib/ext` 目录下的扩展类库。
3.  **应用程序类加载器（Application ClassLoader）：** 负责加载用户类路径（`CLASSPATH`）上的类。

注意：每种加载器只会在自己的范围内搜索加载。

**双亲委派模型（Parent Delegation Model）**

  * 类加载器在加载类时，会首先将加载任务委托给它的父加载器。
  * 如果父加载器无法完成加载，子加载器才会尝试自己加载。
  * **优点：** 避免了类的重复加载，并保证了 Java 核心库的安全性。例如，确保 `java.lang.Object` 类始终由启动类加载器加载，防止恶意代码覆盖核心库。

-----

### 🔹 四、垃圾回收（GC）

垃圾回收是 JVM 内存管理的核心，它负责自动回收不再使用的对象所占用的内存。

#### **判断对象是否可回收**

  * **引用计数法：** 每个对象有一个引用计数器，被引用时加 1，引用失效时减 1。当计数器为 0 时，对象可被回收。这种方法无法解决循环引用问题。
  * **可达性分析算法（主流）：** 从一组被称为 “GC Roots” 的根对象开始，遍历所有引用的对象，形成一个引用链。凡是**不在引用链上**的对象，都将被视为不可达，从而被回收。GC Roots 包括：虚拟机栈中的引用对象、方法区中的静态变量和常量等。

#### **垃圾回收算法**

  * **标记-清除（Mark-Sweep）：**

      * **标记：** 标记出所有可回收的对象。
      * **清除：** 清除这些对象。
      * **缺点：** 产生大量不连续的**内存碎片**。

  * **复制（Copying）：**

      * 将可用内存分为两块，每次只使用其中一块。当这块内存用完时，将存活的对象复制到另一块，然后清空已使用的那块。
      * **优点：** 不会产生内存碎片。
      * **缺点：** 内存利用率低，只有一半可用。通常用于新生代。

  * **标记-整理（Mark-Compact）：**

      * **标记：** 标记出所有可回收的对象。
      * **整理：** 将所有存活的对象向一端移动，然后清理掉边界以外的内存。
      * **优点：** 不会产生内存碎片。

  * **分代收集（Generational Collection）：**

      * 将堆分为**新生代**和**老年代**。
      * 新生代：绝大多数对象在这里创建并快速死亡。使用**复制算法**，因为存活对象少，效率高。
      * 老年代：存放长期存活的对象。使用**标记-清除或标记-整理算法**，因为对象存活率高。

#### **常见的垃圾回收器**

  * **Serial/Serial Old：** 单线程，简单高效，**Stop-the-World**。
  * **ParNew：** Serial 的多线程版本，用于新生代。
  * **CMS（Concurrent Mark Sweep）：**
      * 并发收集器，目标是**最短的停顿时间**。
      * **缺点：** 会产生内存碎片，并发时可能导致**浮动垃圾**。
  * **G1（Garbage-First）：**
      * JDK 1.7 引入的新一代收集器，面向**服务端应用**。
      * 将堆划分为多个区域（Region），可以控制 GC 的停顿时间。
      * **优点：** 并发、并行、分代收集、不产生内存碎片。

-----

### 🔍 五、真实面试高频问题 + 深度解析

#### 1\. JVM 内存区域有哪些？

  * **标准答案：** 程序计数器、虚拟机栈、本地方法栈、堆、方法区。可以区分线程私有和线程共享。
  * **深入：** 最好能说出每个区域的作用、生命周期、以及可能产生的错误（如 `OutOfMemoryError` 或 `StackOverflowError`）。

#### 2\. 堆和栈有什么区别？

  * **标准答案：**
      * **栈**：存储局部变量、方法参数，每个线程私有，生命周期与方法相同，由 JVM 自动管理。
      * **堆**：存储对象实例和数组，所有线程共享，生命周期不确定，由 GC 管理。
  * **深入：** 解释为什么栈上分配比堆上分配快，并提及逃逸分析，即如果对象没有逃逸出方法，JVM 可能会在栈上分配内存，以提高性能。

#### 3\. 什么是类加载的双亲委派模型？有什么好处？

  * **标准答案：**
      * **模型**：类加载器在加载类时，会先委派给父加载器，只有当父加载器无法加载时，子加载器才尝试自己加载。
      * **好处**：保证了核心库的安全性，防止核心类被恶意代码替换；避免了类的重复加载。

#### 4\. JVM 的垃圾回收机制是什么？

  * **标准答案：** GC 通过可达性分析算法判断对象是否可回收，然后使用不同的垃圾回收算法（如标记-清除、复制、标记-整理）来回收内存。
  * **深入：** 提及分代收集，并解释为什么新生代用复制算法，老年代用标记-整理算法。最后，可以简单介绍几个重要的垃圾回收器，如 CMS 和 G1，以及它们的特点。

### 💡 六、口诀 + 表格/图示辅助记忆

**JVM 内存区域口诀**

> **一栈一堆一方法，**
> **计数本地两私有。**
> **堆中对象 GC 管，**
> **栈中栈帧方法走。**

**JVM 运行时数据区**

### 🎁 七、建议 + 误区提醒

**误区提醒**

1.  **把 JVM 内存区域和 JVM 进程的内存混为一谈：** JVM 内存区域是 JVM 自己管理的运行时内存，而 JVM 进程的内存还包括了线程栈、JIT 编译器代码缓存等本地内存。
2.  **认为 `synchronized` 只是一个语法糖：** `synchronized` 的背后是复杂的锁升级和 `Monitor` 机制，其实现与 JVM 内部紧密相关。
3.  **对 GC 算法的理解停留在概念层面：** 在面试中，最好能说出为什么不同的区域采用不同的算法（如新生代用复制，老年代用标记-整理），这能体现你对 JVM 内存管理的深刻理解。

**使用建议**

1.  **结合代码理解：** JVM 的很多概念，如堆、栈、方法区，只有在实际代码中才能更好地理解。
2.  **了解 GC 参数：** 掌握一些常用的 GC 参数，如 `-Xms`、`-Xmx`，这能让你更好地进行 JVM 调优。
3.  **从宏观到微观：** 先掌握 JVM 的整体架构（内存区域），再深入到每个模块的细节（如 GC 算法、类加载流程）。