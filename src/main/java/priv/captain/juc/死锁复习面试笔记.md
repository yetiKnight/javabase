📘 Java 面试复习笔记：死锁

✅ 一、概念简介
● 死锁是指两个或多个线程在执行过程中，因为争夺资源而造成的一种互相等待的现象，导致线程无法继续执行。
● 特性：
  - 互斥：至少有一个资源是以非共享的方式占用的，即某个线程在使用资源时，其他线程不能使用。
  - 占有且等待：一个线程持有至少一个资源，并等待获取其他资源。
  - 不可抢占：已经分配给线程的资源在未使用完之前，不能被其他线程强行抢占。
  - 循环等待：存在一个线程的集合，其中每个线程都在等待下一个线程所持有的资源。

🔹 二、底层原理 + 源码分析
● 死锁的发生通常与线程的资源请求和释放顺序有关。以下是一个简单的死锁示例：

```java
public class DeadlockExample {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread 1: Holding lock 1...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                System.out.println("Thread 1: Waiting for lock 2...");
                synchronized (lock2) {
                    System.out.println("Thread 1: Acquired lock 2!");
                }
            }
        });

        Thread thread2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("Thread 2: Holding lock 2...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                System.out.println("Thread 2: Waiting for lock 1...");
                synchronized (lock1) {
                    System.out.println("Thread 2: Acquired lock 1!");
                }
            }
        });

        thread1.start();
        thread2.start();
    }
}
```
● 关键点：
  - `synchronized` 关键字用于获取锁，可能导致死锁。
  - 线程1持有`lock1`并等待`lock2`，而线程2持有`lock2`并等待`lock1`，形成循环等待。

✅ 三、常用方式 + 代码示例
● 避免死锁的常用策略：
  - **资源请求顺序**：确保所有线程以相同的顺序请求资源。
  - **超时机制**：设置获取锁的超时时间，超时后放弃请求。
  - **死锁检测**：定期检查系统中的死锁情况，并采取措施。

🎯 四、真实面试高频问题 + 深度解析
1. **题目**：什么是死锁？
   - **标准答案**：死锁是多个线程因争夺资源而互相等待，导致无法继续执行的状态。
   - **详细解析**：死锁的四个必要条件是互斥、占有且等待、不可抢占和循环等待。
   - **陷阱警告**：不要简单认为死锁只发生在多线程环境中，单线程也可能因资源请求不当导致逻辑死锁。

2. **题目**：如何避免死锁？
   - **标准答案**：通过资源请求顺序、超时机制和死锁检测等方法避免死锁。
   - **详细解析**：确保所有线程以相同顺序请求资源，设置超时，定期检查死锁状态。
   - **陷阱警告**：避免使用过多的锁，简化锁的使用可以降低死锁的风险。

💡 五、口诀 + 表格/图示辅助记忆
● 口诀：锁顺序要一致，超时放弃不纠缠。
● 表格：死锁的四个条件

| 条件         | 描述                           |
|--------------|--------------------------------|
| 互斥         | 资源不能共享                  |
| 占有且等待   | 持有资源的线程在等待其他资源  |
| 不可抢占     | 资源不能被强制抢占            |
| 循环等待     | 存在循环依赖的资源请求链      |

🎁 六、建议 + 误区提醒
● 易踩的坑：在多线程环境中，尽量减少锁的使用，避免不必要的锁竞争。
● 使用建议：使用`ReentrantLock`可以更灵活地控制锁的获取和释放，避免死锁。