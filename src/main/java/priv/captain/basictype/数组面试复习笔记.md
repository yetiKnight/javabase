📘 Java 面试复习笔记：数组（Array / int[] / Object[]）

✅ 一、概念简介

- **它是什么**：数组是 Java 中最基础的顺序存储结构，元素类型固定、长度固定，支持按下标 O(1) 随机访问。
- **使用场景**：
  - **高频随机读**、低频结构变更（如环形缓冲、Lookup 表、状态表）。
  - **性能敏感**场景（避免装箱/拆箱，减少对象开销）。
  - 作为更高层数据结构的**底层载体**（如 `ArrayList`、`ConcurrentHashMap` 的内部数组）。
- **特性/优缺点**：
  - **优点**：内存连续、CPU 缓存友好、访问 O(1)、原始类型无装箱开销。
  - **缺点**：长度固定（需复制扩容）、插入删除平均 O(n)、不自带越界/空洞修复机制。
- **对比**：
  - **数组 vs ArrayList**：数组长度固定、类型可为原始类型；`ArrayList` 可自动扩容、仅支持引用类型、提供丰富 API。
  - **数组 vs LinkedList**：数组读快写慢；链表增删快（指针操作）但随机访问慢且局部性差。

🔍 二、底层原理 + 源码分析（JDK 8 为主）

- **内存结构**：
  - JVM 中数组是对象，存放在堆；对象头 + `length` + 连续元素区。
  - `length` 为不可变字段，`a.length` 是属性不是方法。
  - 引用类型数组是协变的（`Number[] x = new Integer[10]` 合法），但可能在运行期抛 `ArrayStoreException`。
  - 边界检查：每次 `a[i]` 都会做越界检查（JIT 可做 Bounded Check Elimination）。

- **关键操作与实现思想**：
  - 访问：地址 = `base + index * elementSize`，O(1)。
  - 复制：`System.arraycopy` 为 `native`，语义类似 `memmove`（支持重叠区域），性能极高。
  - 扩容：通过 `Arrays.copyOf` 新建更大数组并复制元素（数组本身不可变长）。
  - 排序：
    - 基本类型 `Arrays.sort(primitive[])` 使用 Dual-Pivot QuickSort（Java 7+），非稳定、快。
    - 对象数组 `Arrays.sort(Object[])` 使用 TimSort（稳定，适合部分有序数据）。
    - `Arrays.parallelSort`（JDK 8）基于 ForkJoin 并行排序（大数组时收益明显）。

- **常见字段/概念说明**：
  - `length`：数组长度，创建后不可变。
  - `componentType`：通过 `array.getClass().getComponentType()` 可取元素类型。
  - `ArrayStoreException`：引用数组写入不兼容子类型时抛出（运行期类型检查）。

- **关键方法/源码（精简示例+注释）**：

```java
// Arrays.copyOf 的核心思路（示意版，JDK 8 真实实现更健壮）
public static int[] copyOf(int[] original, int newLength) {
    int[] copy = new int[newLength];                // 新建目标长度的数组
    System.arraycopy(                               // 使用高性能 native 拷贝
        original, 0,                                // 源数组与起始下标
        copy, 0,                                    // 目标数组与起始下标
        Math.min(original.length, newLength)        // 拷贝长度，避免越界
    );
    return copy;                                    // 返回新数组（旧数组不变）
}

// System.arraycopy（JVM 层 native，语义类似 memmove）
public static native void arraycopy(
    Object src, int srcPos,                         // 源对象与起始位置
    Object dest, int destPos,                       // 目标对象与起始位置
    int length                                      // 拷贝元素个数
);

// 反射创建数组：Array.newInstance
Object newArray = java.lang.reflect.Array.newInstance(String.class, 10); // 创建 String[10]

// 数组边界检查（由 JVM 插入）
int x = arr[i]; // 若 i < 0 或 i >= arr.length，抛出 ArrayIndexOutOfBoundsException
```

- **设计意图与优化**：
  - 通过固定长度 + 连续内存，最大化读性能与局部性；
  - 将“结构变化”外部化（复制/扩容由调用者控制），以换取核心操作的稳定低延迟；
  - JIT 对循环中的越界检查可消除，配合逃逸分析、标量替换进一步优化；
  - 对象数组使用协变满足 OO 语义，但以运行期检查保证类型安全。

✅ 三、常用方式 + 代码示例（含易错点）

```java
// 1) 声明与初始化
int[] a = new int[3];           // 分配长度为3，元素默认值0
int[] b = {1, 2, 3};            // 静态初始化
String[] s = new String[]{"A", "B"}; // 显式 new

// 2) 遍历（for 与增强 for）
for (int i = 0; i < b.length; i++) { // 使用 length 属性，避免 i <= length 越界
    System.out.println(b[i]);        // O(1) 访问
}
for (String v : s) {                 // 增强 for 不暴露下标
    System.out.println(v);
}

// 3) 扩容（本质是复制）：
int[] oldArr = {1, 2, 3};
int[] newArr = java.util.Arrays.copyOf(oldArr, 6); // 后三位为默认值0

// 4) 复制片段：
int[] src = {10, 20, 30, 40, 50};
int[] dest = new int[5];
System.arraycopy(src, 1, dest, 0, 3); // 拷贝 20,30,40 到 dest[0..2]

// 5) 排序（原地修改）：
int[] nums = {5, 1, 4, 2};
java.util.Arrays.sort(nums);          // 基本类型：Dual-Pivot QuickSort

// 6) 对象数组排序（自定义比较器）：
String[] names = {"ccc", "bb", "aaaa"};
java.util.Arrays.sort(names, java.util.Comparator.comparingInt(String::length)); // 稳定

// 7) 并行排序（大数组）：
java.util.Arrays.parallelSort(nums);  // ForkJoin 并行，适合大数据量

// 8) 比较与打印：
int[] x = {1,2};
int[] y = {1,2};
System.out.println(x == y);                       // false：不同引用
System.out.println(java.util.Arrays.equals(x, y)); // true：逐元素比较
System.out.println(java.util.Arrays.toString(x));  // [1, 2]

// 9) 多维（实为“数组的数组”）：
int[][] grid = new int[2][3];        // 两行三列（每行是一个 int[]）
grid[0][1] = 42;                     // 先索引行，再索引列

// 10) Arrays.asList 易错点：
Integer[] boxed = {1, 2, 3};
java.util.List<Integer> list1 = java.util.Arrays.asList(boxed); // 固定大小的 List
// list1.add(4); // 运行期抛 UnsupportedOperationException

int[] primitives = {1, 2, 3};
java.util.List<int[]> list2 = java.util.Arrays.asList(primitives); // 注意：这里是 List<int[]>，只有一个元素（整个数组）

// 11) 深浅拷贝：
int[] shallow = x.clone(); // 基本类型是值复制；对象数组是引用复制（浅拷贝）

// 12) 查找：
int idx = java.util.Arrays.binarySearch(nums, 4); // 二分查找（需已排序），返回索引或负的插入点-1
```

- **线程安全与异常**：
  - 数组本身非线程安全；并发读写需外部同步或使用并发容器封装。
  - 越界抛 `ArrayIndexOutOfBoundsException`；引用数组不兼容写入抛 `ArrayStoreException`。

🎯 四、真实面试高频问题 + 深度解析

1) 题目：数组的时间复杂度特征？
- 标准答案：随机访问 O(1)，按值查找 O(n)，中间插入/删除 O(n)。
- 详细解析：内存连续 → 地址可直接计算；结构变更需移动后续元素；若尾部追加且有空间，摊销 O(1)（但数组长度固定，通常需复制）。
- 陷阱警告：把“插入/删除 O(1)”当成普适结论，忽略位置与移动成本。

2) 题目：为什么 Java 数组长度不可变？
- 标准答案：保证连续内存与对象 header/length 不变性，简化 JVM 实现并优化性能。
- 详细解析：固定长度使越界检查与地址计算可优化；动态扩容交由上层（如 `ArrayList`）通过复制实现。
- 陷阱警告：误以为有 `resize` 方法，或把 `length()` 当方法调用。

3) 题目：`System.arraycopy` 与循环复制的差异？
- 标准答案：`arraycopy` 为 native，语义类似 `memmove`，可处理区间重叠，通常更快。
- 详细解析：JVM 可使用高度优化的本地实现/指令（SIMD、内存带宽优化），而 for 循环难以匹敌；并保序处理重叠区间。
- 陷阱警告：错误使用起止位置导致越界；忽略重叠时的语义差异。

4) 题目：对象数组为何可能抛 `ArrayStoreException`？
- 标准答案：数组是协变的，运行期会检查写入元素是否与实际数组的运行期元素类型兼容，不兼容则抛异常。
- 详细解析：`Number[] arr = new Integer[10]; arr[0] = 1.5` → 运行期检查失败抛异常；保证类型安全。
- 陷阱警告：把泛型不变性与数组协变性混淆。

5) 题目：`Arrays.sort` 的实现与稳定性？
- 标准答案：基本类型用 Dual-Pivot QuickSort（不稳定），对象数组用 TimSort（稳定）。
- 详细解析：JDK 7+ 引入双轴快排；对象排序选择 TimSort 以利用部分有序，提高实际性能并保持稳定性。
- 陷阱警告：误答“全部都是快排/全部稳定”。

6) 题目：`Arrays.asList` 的坑？
- 标准答案：返回固定大小列表，修改结构性操作抛异常；传入基本类型数组会被当成单个元素。
- 详细解析：底层是 `Arrays$ArrayList` 视图，增删不支持；需要可变列表应 `new ArrayList<>(Arrays.asList(...))`。
- 陷阱警告：直接对返回 List 调 `add/remove`；或期望拆箱后的列表。

7) 题目：多维数组在 JVM 的内存布局？
- 标准答案：实为“数组的数组”，每一维都是独立对象，可能不规则（Jagged）。
- 详细解析：`new int[2][3]` 创建 1 个 `int[][]` + 2 个 `int[]`；可让第二维长度不同。
- 陷阱警告：以为是 C 风格的连续二维块，导致在拷贝/遍历时假设错误。

8) 题目：数组与 `ArrayList` 的选择？
- 标准答案：读多写少、性能敏感、已知固定上限 → 数组；需动态伸缩、丰富 API、泛型方便 → `ArrayList`。
- 详细解析：数组避免装箱且连续内存有更佳局部性；`ArrayList` 付出扩容与装箱成本换取易用性与灵活性。
- 陷阱警告：无脑用 `ArrayList` 在热路径上；或用数组却频繁扩容复制。

9) 题目：`binarySearch` 的返回值语义？
- 标准答案：找到则返回索引；否则返回 `(-(插入点) - 1)`。
- 详细解析：插入点为使数组仍有序的索引；可用 `int insertPos = -idx - 1;` 复原。
- 陷阱警告：忽略负值编码，直接当作“没找到返回 -1”。

10) 题目：并行排序何时收益明显？
- 标准答案：数据量大且核数足、比较/移动成本不低、内存带宽不是瓶颈时。
- 详细解析：`Arrays.parallelSort` 基于 ForkJoin；小数组因调度开销不划算。
- 陷阱警告：对小数组/频繁调用盲目使用并行排序。

💡 五、口诀 + 表格/图示辅助记忆

- **口诀**：
  - ✅ 查快增删慢，长度一旦定；扩容用拷贝，排序看类型。
  - ✅ 对象协变慎，存错抛异常；`asList` 不可改，原始别忘装。

- **对比表**：

| 维度 | 数组 | ArrayList | LinkedList |
| --- | --- | --- | --- |
| 长度 | 固定 | 可扩容（复制） | 动态（链表节点） |
| 访问 | O(1) | O(1) | O(n) |
| 插入删除 | 中间 O(n) | 中间 O(n) | O(1)（已知节点） |
| 元素类型 | 支持原始/引用 | 仅引用（自动装箱） | 仅引用 |
| 内存局部性 | 极好 | 好 | 差 |
| 典型排序 | Dual-Pivot QS / TimSort | 同数组 | 不适用（非连续） |

🎁 六、建议 + 误区提醒（实战）

- **越界与 off-by-one**：循环边界用 `< length`；谨慎 `i <= length-1`。
- **打印与比较**：打印用 `Arrays.toString/Arrays.deepToString`；比较用 `Arrays.equals/deepEquals`。
- **`asList` 坑**：需要可变列表要 `new ArrayList<>(Arrays.asList(...))`；基本类型数组先装箱或使用流 `IntStream.of(arr).boxed().collect(...)`。
- **深浅拷贝**：对象数组 `clone` 是浅拷贝；深拷贝需逐个元素复制或序列化方案。
- **并发**：数组不是并发容器；多线程写需外部同步或使用 `Atomic*Array`、`CopyOnWriteArrayList` 等。
- **性能**：热路径优先数组；批量移动用 `System.arraycopy`；大数组排序可评估 `parallelSort`。
- **版本差异**：JDK 7+ 基本类型排序是双轴快排；JDK 8 引入 `parallelSort`；边界检查消除依赖 JIT 与代码形状。

—— 完 ——


