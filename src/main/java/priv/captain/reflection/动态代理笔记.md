📘 Java 面试复习笔记：动态代理 (Dynamic Proxy)

-----

### ✅ 一、概念简介

✅ **什么是动态代理？**

**动态代理** (Dynamic Proxy) 是一种在 **程序运行时** 动态生成代理类和代理对象的技术。它允许我们在不修改目标对象源代码的情况下，为其方法添加额外的逻辑（如日志、事务、权限控制等）。这种模式属于设计模式中的 **代理模式**，与需要手动编写代理类的 **静态代理** 相比，动态代理更加灵活和通用。

🔹 **与静态代理的对比**

  * **静态代理：** 需要手动为每个目标类编写一个代理类，代理类和目标类都实现同一个接口。缺点是代码冗余，耦合度高，当接口增加或改变时，所有代理类都需要修改。
  * **动态代理：** 在运行时通过反射等机制自动生成代理类。你只需要实现一个通用的 `InvocationHandler` (或 `MethodInterceptor`)，就能为任意实现了接口的目标对象生成代理。

🔹 **两种主要的动态代理实现**

1.  **JDK 动态代理：**

      * **特点：** 基于接口（Interface）。
      * **原理：** 运行时生成一个实现了目标接口的代理类，该代理类会继承 `java.lang.reflect.Proxy`。
      * **适用场景：** 目标类必须实现至少一个接口。

2.  **CGLIB 动态代理：**

      * **特点：** 基于继承（Class）。
      * **原理：** 运行时生成一个目标类的子类，并重写父类的方法。
      * **适用场景：** 目标类可以不实现接口，但不能是 `final` 类或包含 `final` 方法。

-----

### 🔍 二、底层原理 + 源码分析

🔹 **JDK 动态代理底层原理**

JDK 动态代理的核心是 `java.lang.reflect.Proxy` 和 `java.lang.reflect.InvocationHandler`。

**流程详解：**

1.  **定义接口和实现类**：首先，你需要定义一个接口和它的实现类（目标类）。
2.  **定义`InvocationHandler`**：编写一个实现了 `InvocationHandler` 接口的类，它包含了代理的额外逻辑。
3.  **调用`Proxy.newProxyInstance()`**：通过这个静态方法创建代理对象。

**源码解析 `Proxy.newProxyInstance()`：**

```java
// java.lang.reflect.Proxy#newProxyInstance
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h) throws IllegalArgumentException {
    // 1. 参数校验，确保 h 不为空
    Objects.requireNonNull(h);
    
    // 2. 查找或生成代理类的Class对象
    // 通过 ProxyClassFactory 创建或从缓存中获取代理类的Class对象
    Class<?> cl = getProxyClass0(loader, interfaces);
    
    // 3. 获取代理类的构造器
    // 获取带 InvocationHandler 参数的构造器
    final Constructor<?> cons = cl.getConstructor(constructorParams);
    
    // 4. 通过构造器创建代理对象并返回
    // 这一步会调用代理类的构造器，并将 InvocationHandler 实例传入
    return cons.newInstance(new Object[]{h});
}
```

**代理类 `$Proxy0` 的字节码分析（简化版）：**

  * JDK 动态代理在运行时会生成一个代理类（如 `$Proxy0.class`），这个类：
      * 继承 `java.lang.reflect.Proxy`。
      * 实现目标接口。
      * 包含一个 `InvocationHandler` 成员变量。
      * 重写接口的所有方法。在重写的方法内部，它会调用 `InvocationHandler` 的 `invoke()` 方法，将方法名和参数传递过去。

<!-- end list -->

```java
// 伪代码：JDK动态生成的代理类
public final class $Proxy0 extends Proxy implements MyInterface {
    
    // 构造器，传入 InvocationHandler
    public $Proxy0(InvocationHandler h) {
        super(h); 
    }

    // 重写了接口方法
    public void doSomething() {
        // ... 省略方法查找
        try {
            // 核心：调用 InvocationHandler 的 invoke 方法
            // h：传入的 InvocationHandler 实例
            // m：代表当前正在调用的方法（doSomething）的 Method 对象
            // args：方法参数数组
            super.h.invoke(this, m, null);
        } catch (RuntimeException | Error e) {
            throw e;
        } catch (Throwable e) {
            // ... 异常处理
        }
    }
}
```

🔹 **CGLIB 动态代理底层原理**

  * **核心组件**：`net.sf.cglib.proxy.Enhancer` 和 `net.sf.cglib.proxy.MethodInterceptor`。
  * **流程**：`Enhancer` 根据目标类生成一个**子类**，并使用 `MethodInterceptor` 作为回调。
  * **原理**：
      * CGLIB 使用字节码生成工具 **ASM** 在运行时创建目标类的子类。
      * 这个子类重写了父类所有\*\*非`final`\*\*方法。
      * 在重写的方法中，它会调用 `MethodInterceptor` 的 `intercept()` 方法，将控制权交给自定义的拦截器。

-----

### ✅ 三、常用方式 + 代码示例

**场景：为用户服务添加日志功能**

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Arrays;

// 1. 定义一个接口
interface UserService {
    String getNameById(int id);
}

// 2. 实现接口的目标类
class UserServiceImpl implements UserService {
    @Override
    public String getNameById(int id) {
        System.out.println("--- 正在执行业务逻辑，查询用户ID：" + id + " ---");
        return "User-" + id;
    }
}

// 3. 编写 InvocationHandler，包含代理逻辑
class LogInvocationHandler implements InvocationHandler {
    private final Object target; // 目标对象

    public LogInvocationHandler(Object target) {
        this.target = target;
    }

    /**
     * @param proxy  代理对象实例（通常不用）
     * @param method 正在被调用的方法对象
     * @param args   调用方法时传入的参数
     * @return 方法的返回值
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("--- 方法开始前：日志记录 ---");
        System.out.println("方法名: " + method.getName());
        System.out.println("参数: " + Arrays.toString(args));

        // 核心：通过反射调用目标对象的实际方法
        Object result = method.invoke(target, args);

        System.out.println("--- 方法结束后：日志记录 ---");
        System.out.println("返回值: " + result);
        return result;
    }
}

public class JdkProxyDemo {
    public static void main(String[] args) {
        // 目标对象
        UserService target = new UserServiceImpl();
        
        // 创建 InvocationHandler 实例
        LogInvocationHandler handler = new LogInvocationHandler(target);
        
        // 通过 Proxy.newProxyInstance() 创建代理对象
        // 参数1: 类加载器，通常使用目标对象的类加载器
        // 参数2: 目标对象实现的接口数组，重要！
        // 参数3: 代理逻辑处理器
        UserService proxy = (UserService) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            handler
        );
        
        // 调用代理对象的方法，实际上会执行 LogInvocationHandler 的 invoke 方法
        String name = proxy.getNameById(10);
        System.out.println("最终获取到的用户名：" + name);
    }
}
```

**代码要点：**

  * `Proxy.newProxyInstance()` 方法的第二个参数是**接口数组**，这是 JDK 动态代理的核心约束。
  * 在 `invoke()` 方法中，`method.invoke(target, args)` 是反射调用的核心，它将方法调用委派给真正的目标对象。
  * `InvocationHandler` 接口的设计巧妙，它将“谁来处理”（`handler`）和“处理什么”（`target`）解耦。

-----

### 🔹 四、实际应用场景 / 项目落地

动态代理是 Java 框架的基石，主要用于实现 **AOP** (面向切面编程)。

  * **Spring 框架的 AOP：**
      * **事务管理 (`@Transactional`)**：Spring 在方法执行前后通过动态代理植入事务管理逻辑（开启事务、提交/回滚）。
      * **权限控制**：在方法调用前进行权限校验，如果失败则抛出异常。
      * **方法性能监控**：代理方法在执行前后记录时间戳，计算方法执行耗时。
  * **RPC (远程过程调用) 框架：**
      * 例如 Dubbo、Spring Cloud Feign。当你调用一个远程服务的接口时，框架会为你生成一个动态代理对象。这个代理对象拦截方法调用，将方法名、参数等信息序列化，并通过网络发送给远程服务，然后等待结果并反序列化返回。对调用者来说，就如同调用本地方法一样简单。
  * **MyBatis 框架：**
      * 当你使用 `SqlSession.getMapper(UserMapper.class)` 获取 Mapper 接口的实例时，MyBatis 内部就是通过动态代理，为 `UserMapper` 接口生成一个代理对象。当你调用 `userMapper.selectUserById()` 方法时，代理对象会拦截该调用，执行相应的 SQL 语句。

-----

### 🎯 五、真实面试高频问题 + 深度解析

#### 1\. JDK 动态代理和 CGLIB 动态代理有什么区别？

  * **标准答案：**

      * **基础不同：** JDK 动态代理基于接口，CGLIB 动态代理基于继承。
      * **实现方式：** JDK 在运行时生成一个实现目标接口的代理类；CGLIB 在运行时生成一个继承目标类的子类。
      * **限制：** JDK 代理要求目标类必须实现接口；CGLIB 代理不能代理 `final` 类或 `final` 方法。
      * **性能：** 在 JDK 1.6 之前，CGLIB 性能更优。但随着 JDK 版本的优化，两者性能差异已不明显，在某些场景下 JDK 动态代理甚至更快。

  * **详细解析：**

      * **JDK 代理**生成的代理类继承 `Proxy` 类，而 Java 是单继承的，所以无法再继承其他类，只能实现接口，这就是它**只能代理接口**的根本原因。
      * **CGLIB 代理**通过创建子类来重写父类方法实现代理，因此它可以代理没有实现接口的普通类。但 `final` 关键字阻止了继承和方法重写，所以它**无法代理`final`的类或方法**。

  * **陷阱警告：** 不要只回答“一个基于接口一个基于类”，要能说出其背后**Java 单继承的限制**和 **`final` 关键字**的原理。

#### 2\. 为什么说动态代理比静态代理更灵活？

  * **标准答案：** 动态代理可以为**任意多个**实现了相同接口的目标对象生成代理，而无需手动编写每个代理类。
  * **详细解析：** 在静态代理中，如果你有 100 个业务接口，就需要写 100 个代理类，这会带来巨大的代码量和维护负担。而动态代理只需要一个 `InvocationHandler`（或 `MethodInterceptor`），就能通过反射机制为这 100 个接口动态生成代理对象，实现了业务逻辑与代理逻辑的彻底分离。

#### 3\. JDK 动态代理中 `InvocationHandler` 的 `invoke()` 方法的参数有什么作用？

  * **标准答案：**
      * `Object proxy`：代理对象本身。通常很少用，因为在 `invoke` 方法内部，直接使用 `proxy` 对象进行方法调用会陷入无限递归。
      * `Method method`：被调用的方法对象，可以通过它获取方法名、参数类型、返回值类型等信息。
      * `Object[] args`：方法调用时的参数数组。
  * **详细解析：** `invoke` 方法是动态代理的核心，`method` 和 `args` 提供了**足够的信息**，使得你可以通过 `method.invoke(target, args)` 精准地调用目标对象的对应方法，并在其前后添加自定义逻辑。

-----

### 💡 六、口诀 + 表格/图示辅助记忆

  * **动态代理口诀：**

      * **“JDK 要接口，CGLIB 靠子类。”**
      * **“接口一传，代理即现；逻辑都在 Handler 间。”**

  * **对比表格：JDK vs. CGLIB**

| 特性 | JDK 动态代理 | CGLIB 动态代理 |
| :--- | :--- | :--- |
| **基础** | 基于接口 | 基于类继承 |
| **代理对象** | 实现了接口的`Proxy`子类 | 目标类的子类 |
| **实现类** | `java.lang.reflect.Proxy` | `net.sf.cglib.proxy.Enhancer` |
| **核心接口** | `InvocationHandler` | `MethodInterceptor` |
| **限制** | 目标类必须实现接口 | 不能代理`final`类/方法 |
| **性能** | 第一次创建快，后续调用稍慢 | 第一次创建慢，后续调用快（现代 JDK 差距缩小） |

-----

### 🎁 七、建议 + 误区提醒

  * **性能误区：** 不要认为动态代理性能很差。虽然反射调用有开销，但现代 JVM 已经对 `Method.invoke()` 进行了优化，特别是 JIT 编译器会将频繁调用的反射方法内联。在大多数业务场景下，这点开销可以忽略不计。
  * **适用性误区：** 不是所有情况都必须使用动态代理。如果代理逻辑简单且目标类不常变，静态代理可能更简单直接。
  * **Spring 默认选择：** 了解 Spring 的默认策略。当目标 Bean **实现了接口**时，Spring 默认使用 **JDK 动态代理**。当目标 Bean **没有实现接口**时，则使用 **CGLIB 动态代理**。可以通过配置强制使用 CGLIB。
  * **线程安全：** 动态代理本身是线程安全的，因为代理对象的创建和使用是针对单个实例的。但你**在`InvocationHandler`中实现的业务逻辑**如果涉及共享资源，则需要自己保证其线程安全。

-----

### 🎯 八、面试答题技巧

1.  **开门见山：** 先简明扼要地定义动态代理是什么，以及它解决了什么问题（与静态代理的对比）。
2.  **核心对比：** 立即抛出 JDK 和 CGLIB 这两个关键概念，并清晰地阐述它们的**核心区别**（基于接口 vs. 基于继承），这是最重要的加分项。
3.  **深入原理：** 结合源码（`Proxy.newProxyInstance()`）和伪代码，解释代理对象是如何被动态生成，以及方法调用是如何被拦截并委派给 `InvocationHandler` 的。
4.  **项目落地：** 结合你自己的项目经验，或者以 Spring 事务、MyBatis Mapper 为例，说明动态代理在实际业务中的应用，体现你的实战能力。
5.  **总结升华：** 最后，提一下动态代理的优缺点，特别是性能和版本差异，以及使用时的注意事项。这样能展现出你对这个知识点的全面掌握。